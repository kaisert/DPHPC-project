\section{Background}\label{sec:background}
We start this section by giving a brief introduction to the XML Path Language,
or XPath for short \cite{xpathSpec}. We continue by providing a brief overview
over three general approaches for XPath Query processing and discuss how our
solution relates to these approaches. Finally, we present a formal description
of the push-down automatons that we use in our approach.

\subsection{XML Querying using XPath}

For the purposes of this project we only considered a small subset of XPath.
The expressiveness of this subset is fairly limited compared to full XPath.
However, we believe that the concepts presented in this report can be extended
in a canonical way to support more expressive queries.

XPath models an XML document as a tree of nodes. An XPath path expression
describes a path in this tree. In our case, the path always starts at the root
node and, also, a path expression might match multiple nodes of a tree.

The grammar rules for the subset of XPath we chose are as follows:

\begin{align*}
    P &::= /N\ |\ //N\ |\ P\ P\\
    N &::= E\ |\ *
\end{align*}
where $E$ is an element name. In our terminology, a \emph{query} is a set of
path expressions. The following is an example of a query containing two path
expressions:

\begin{figure}[htb]
\centering
\texttt{/a/b/c}\\
\texttt{//*/d}
\end{figure}

We can now give a formal definition of the problem we aim to solve and state
the goal of our enterprise. 

\mypar{Problem Definition and Goal} Given an XML Document and a XPath query (as
defined above), find all nodes that match any of the path expression contained
in the query and report the character offsets in the XML Document of the
opening and closing tags of these nodes. The goal is to maximize the throughput
at which the XML Document is processed.

Consider the example XML Document in Figure \ref{src:exampleXML}. Using the
above query, the matcher would return the character offsets of \verb;<c>; and
\verb;</c>;, and \verb;<d>; and \verb;</d>; for the first and second path
expression, respectively.

\lstset{
         numbers=left
 }

\begin{figure}[htb]
\begin{lstlisting}
    <a>
        <b>
            <c>
            </c>
        </b>
        <b>
            <d>
            </d>
        </b>
    </a>
\end{lstlisting}
\caption{Example XML Document}
\label{src:exampleXML}
\end{figure}

% TODO syntax description

\subsection{Parallel XML Query Matching}
To decide whether a node matches an path expression, all characters of the XML
stream up to that node must be read. This is the major challenge in processing
XML data.

In the following we briefly discuss three commonly available techniques for
processing XML data. The idea is not to provide detailed technical insight, but
rather to demonstrate how the aforementioned challenge is met in these
scenarios. We refer the reader to \cite{Ogden2013} for a more elaborate
discussion.

\mypar{XML parsing and querying} As XML is a context-free language, an XML
document can be parsed and represented as a parse tree. The actual query
matching is then performed on the parse tree.

There exist approaches to parallelize parse tree querying \cite{You11}. However,
in general, parsing an XML document in parallel requires the document to be
split into well-formed chunks, each containing a subtree of the parse tree.
This, in turn, can only be achieved through a sequential pre-parsing step.

An example for a parallel DOM tree parser that works on malformed XML chunks is
discussed in \cite{Shah09}. However, they only considered XML documents of
comparatively small size.

\mypar{XML-capable DBMS} Some relational DBMS-engines (among them are MSQL,
MySQL, MonetDB) have support for indexing XML documents. While indexing enables
efficient and parallel querying, creating the index structures imposes a large
overhead, as the XML Document must first be read into the database and then
indexed.

\mypar{XML processing with automatons} 
A parser (e.g. a SAX-parser) reads the XML document and triggers parsing events
that are handled by a (pushdown) automaton. The automaton transitions
into an accepting state if one of the path expressions of the input query matches.

One advantage of this approach is that both the parser and the automaton need to
maintain only comparatively little state. Indeed, the authors of
\cite{Ogden2013} which is the inspiration for this project, claim that it is the
low memory bandwidth requirements that make their approach better than the
alternative DOM-tree approach which they compare against.

\subsection{XPath Query Matching}
We used the same methods to construct the \emph{deterministic pushdown automata}
as in \cite{Ogden2013}: A query is turned into a deterministic finite state
automaton (dFSA) using the methods presented in \cite{Green2014}. The dFSA is
then turned into a pushdown automaton (or pushdown transducer).

A deterministic pushdown automaton is defined as a 6-tuple $(Q, q_0, \Sigma,
\Gamma, \delta, F)$ where $Q$ is the set of states, $q_0$ is the initial state,
$\Sigma$ is the input alphabet (the opening and closing XML tags), $\Gamma$ is
the pushdown alphabet, $\delta$ is the transition function, and $F \subseteq Q$ is
the set of accepting states.

In our case, the pushdown alphabet $\Gamma$ is equal to the set of states $Q$.
Each opening tag leads to a push transition, i.e. the current state is pushed
onto the stack. Conversely, each closing tag corresponds to a pop transition
where the new state is the former top of the stack.

% Thus, the transition
% function consists of two parts, $\delta_{\text{push}}: Q \times \Sigma
% \rightarrow Q \times \Gamma$ and $\delta_{\text{pop}}: Q \times \Sigma \times
% \Gamma \rightarrow Q$.

\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   \node[state,initial] (q_1)   {$1$};
   \node[state] (q_2) [right=of q_1] {$2$}; 
   \node[state] (q_3) [right=of q_2] {$3$}; 
   \node[state,accepting](q_4) [right=of q_3] {$4$};
   \node[state] (q_0) [below=2.5cm of q_2, xshift=0.75cm] {$0$};
    \path[->] 
    (q_1) edge  node {a}   (q_2)
    (q_2) edge  node {b}   (q_3)
    (q_3) edge  node {c}   (q_4) 
    (q_1) edge[bend right]  node {[o]} (q_0)
    (q_2) edge  node {[o]} (q_0)
    (q_3) edge  node {[o]} (q_0)
    (q_4) edge[bend left]  node {[o]} (q_0);
\end{tikzpicture}
\caption{State Diagram of a dPDA for path expression \texttt{/a/b/c}}
\label{fig:exampleFSA}
\end{figure}

Figure \ref{fig:exampleFSA} shows the state diagram of a pushdown automaton
matching nodes of the path expression \verb;/a/b/c;. The state $0$ corresponds
to the \emph{illegal state}. It is reached when no subsequent input characters
can lead to a match (e.g., when an opening tag \verb;<d>; is read in this case).
The transitions labeled \verb;[o]; match all input characters for which there
are no specific transitions. The pop transitions are omitted for brevity.


%ive a short, self-contained summary of necessary
%ackground information. For example, assume you present an
%mplementation of sorting algorithms. You could organize into sorting
%efinition, algorithms considered, and asymptotic runtime statements. The goal of the
%ackground section is to make the paper self-contained for an audience
%s large as possible. As in every section
%ou start with a very brief overview of the section. Here it could be as follows: In this section 
%e formally define the sorting problem we consider and introduce the algorithms we use
%ncluding a cost analysis.

%mypar{Sorting}
%recisely define sorting problem you consider.

%mypar{Sorting algorithms}
%xplain the algorithm you use including their costs.

%s an aside, don't talk about "the complexity of the algorithm.'' It's incorrect,
%roblems have a complexity, not algorithms.

