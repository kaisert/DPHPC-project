\section{Background}\label{sec:background}
In this section, we first give the problem definition while simultaneously
introducing the (subset of the) XML Path Language–or XPath for short–
%TODO:Ref Xpath.
by giving small running examples.
We then give a general overview over three main design approaches for XPath
Query Processors and briefly discuss how our solution relates to these
approaches (TODO maybe not). Finally, we provide a formal description of the
push-down automatons that we use in our approach.

\subsection{XML Querying using XPath}

XPath models an XML document as a tree of nodes. Each node of an XML document
can be addressed by an path expressions. A path expression might \emph{match}
multiple nodes in an XML document.

For the purposes of this project we only consider a limited subset of path
expressions. However, we believe that the methods and concepts provided in this
report can be extended in a canonical way to support a more expressive path
expressions. The grammar rules for the subset we chose are as follows:

% TODO: syntax

Figure TODO shows two examples of XPath queries. The first and second both match
the same node.

/a/b/c
/a/*/c

\mypar{Problem Definition (informal).} Given an XML Document and a set of XPath
expressions (as defined above), report all nodes that match any of the given
path expressions. The goal is to maximize the throughput at which the XML
Document is processed.

% TODO syntax description

\subsection{Parallel XML Query Matching}
To decide the whether a node matches an XPath expression, all characters of the
XML stream up to that node must be read. This is the major challenge in
processing XML data.

In the following we briefly mention three common techniques for processing XML
data. The idea is not to provide detailed technical insight, but rather to
demonstrate how the aforementioned fact is accommodated for in different
setups. We refer the reader to \todo{pptranducer} for a more elaborate
discussion.

\mypar{XML parsing and querying.} As XML is a context-free language, an XML
document can be parsed and represented as a parse tree. There exist approaches
to parallelize parse tree querying \todo{35 in pptranducer}. However, parsing
an XML document in parallel requires the document to be split into well-formed
chunks, each containing a subtree of the parse tree. This, in turn, can only be
achieved through a sequential pre-parsing step.

Approaches for parallel DOM Tree parsers have been discussed in the literature.
For instance, in \todo{cite this other paper where they have created a tree
parser for open office documents}, ... However, according to its authors, this
approach is only suitable for comparatively small documents, according to the
authors.

\mypar{XML-capable DBMS.}

Some relational DBMS-engines (MSQL, MySQL, MonetDB) have support for indexing
XML documents. While indexing enables efficient querying, creating the index
structures imposes a comparatively large overhead, which renders this method
unsuitable for stream processing.

\mypar{XML processing with automatons.} 

A parser (e.g. a SAX-parser) reads the XML document and triggers parsing events
that are handled by a (pushdown) automaton. The pushdown automaton transitions
into an accepting state if one the path expressions of the input query matches.

One advantage of this approach is that both the parser and the automaton need to
maintain only comparatively little state. Indeed, the authors of \todo{citation}
which is the inspiration for this project, claim that it is the low memory
bandwidth requirements that make their approach better than the alternative
DOM-tree approach which they compare against.

\subsection{XPath Query Matching}



%ive a short, self-contained summary of necessary
%ackground information. For example, assume you present an
%mplementation of sorting algorithms. You could organize into sorting
%efinition, algorithms considered, and asymptotic runtime statements. The goal of the
%ackground section is to make the paper self-contained for an audience
%s large as possible. As in every section
%ou start with a very brief overview of the section. Here it could be as follows: In this section 
%e formally define the sorting problem we consider and introduce the algorithms we use
%ncluding a cost analysis.

%mypar{Sorting}
%recisely define sorting problem you consider.

%mypar{Sorting algorithms}
%xplain the algorithm you use including their costs.

%s an aside, don't talk about "the complexity of the algorithm.'' It's incorrect,
%roblems have a complexity, not algorithms.

